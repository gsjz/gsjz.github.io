<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>yzl_lec3</title>
    <link rel="icon" href="favicon.ico">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/white.css">
    <link rel="stylesheet" href="plugin/highlight/zenburn.css">
    <link rel="stylesheet" href="src/mysetting.css">
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h1>yzl_lec3</h1>
                date: 25.08.06
            </section>

            <section>
                <h2>课程大纲</h2>
                <li>多项式前缀和</li>
                <li>根号分治</li>
                <li>换序技巧</li>
                <li>反演技巧</li>
            </section>

            <section>
                <section>
                    <h2>多项式前缀和</h2>
                </section>
                <section>
                    <h3>故事的开头...</h3>
                    $$
                    \sum\limits_{k=0}^{n} k = \frac{n(n+1)}{2}
                    $$

                    <p class="fragment">So easy?...</p>
                </section>
                <section>
                    $$
                    \sum\limits_{k=0}^{n} k^2
                    $$
                </section>
                <section>
                    <h3>扰动法</h3>
                    <div style="font-size: 55%">
                        我考虑这样的两个函数（扰动 F 得到 G）

                        $$
                        F(n) = \sum\limits_{k=0}^{n}k^2,\quad G(n) = \sum\limits_{k=0}^{n}(k+1)^2
                        $$

                        用两种方法计算 $G(n) - F(n)$。

                        <p class="fragment">第一种：直接得到 $(n+1)^2$。</p>
                        <p class="fragment">
                            第二种：将 $(k+1)^2$ 拆成 $k^2 + 2k + 1$，
                            <b class="fragment">我知道 $\sum\limits_{k=0}^{n}k = \frac{n(n+1)}{2}$ ，</b>
                            <span class="fragment">
                                那么我可以算出
                                $$
                                G(n) = F(n) + n\cdot (n+1) + (n+1)
                                $$
                            </span>
                        </p>

                        <p class="fragment">
                            两种算法结果是一致的，这似乎并没有给出任何信息？
                            <span class="fragment fade-out">😅</span>
                        </p>
                        <p class="fragment">
                            实际上只是你知道得太多了。
                            <span class="fragment"> 如果一个外星人👽没有听过神童高斯的故事，它可能就通过这种方式来推导 $\sum\limits_{k=0}^{n}k$。</span>
                            <span class="fragment">
                                聪明的外星人🤓还会用这种方法计算 $\sum\limits_{k=0}^{n}k^2,\sum\limits_{k=0}^{n}k^3,\cdots$
                            </span>
                        </p>
                    </div>
                </section>
                <section>
                    $$
                    \sum\limits_{k=0}^{n} k^d
                    $$
                </section>

                <section>
                    <div>\( \sum_{k=1}^n k^0 = n \)</div>
                </section>

                <section>
                    <div>\( \sum_{k=1}^n k^1 = \frac{1}{2}n^2 + \frac{1}{2}n \)</div>
                </section>

                <section>
                    <div>\( \sum_{k=1}^n k^2 = \frac{1}{3}n^3 + \frac{1}{2}n^2 + \frac{1}{6}n \)</div>
                </section>

                <section>
                    <div>\( \sum_{k=1}^n k^3 = \frac{1}{4}n^4 + \frac{1}{2}n^3 + \frac{1}{4}n^2 \)</div>
                </section>

                <section>
                    <div>\( \sum_{k=1}^n k^4 = \frac{1}{5}n^5 + \frac{1}{2}n^4 + \frac{1}{3}n^3 - \frac{1}{30}n \)</div>
                </section>

                <section>
                    <div>\( \sum_{k=1}^n k^5 = \frac{1}{6}n^6 + \frac{1}{2}n^5 + \frac{5}{12}n^4 - \frac{1}{12}n^2 \)
                    </div>
                </section>
                <section>
                    <h3>多项式前缀和</h3>
                    <p>
                        对于多项式 $f(n)$，它有这样形式的前缀和函数
                        $$
                        g(n) = \sum\limits_{k=0}^{n} f(i)
                        $$
                        上面讨论的是 $f(n) = n^{d}$ 的特例。可以知道，$g(n)$ 是一个 $d+1$ 次多项式。
                    </p>
                </section>
                <section>
                    <h3>一般结论</h3>
                    <p class="fragment">多项式前缀和的结果是一个次数高一次的多项式。</p>
                    <p class="fragment">这个技巧出现在 NOIP2020 微信步数，以及众多模拟题中。</p>
                    <p class="fragment">它有一个比较固定的搭配技巧，即维护一些多项式的点值（而非系数）进行转移。然后再通过点值还原多项式的系数（Lagrange 插值），此处暂且不表，仅作初步印象。
                    </p>
                </section>
            </section>

            <section>
                <section>
                    <h2>根号分治</h2>
                </section>
                <section>
                    <p class="fragment" data-fragment-index="1">
                        如何快速枚举 n 的因子？
                        <span class="fragment" data-fragment-index="5">（算法层面的分类）</span>
                    </p>
                    <p class="fragment" data-fragment-index="2">
                        如何简单估计 n 的因子数量？
                        <span class="fragment" data-fragment-index="6">（理论层面的分类）</span>
                    </p>
                    <p class="fragment" data-fragment-index="3">
                        根号分治，就是将讨论的对象，按照一个阈值划分成两类。
                        <span class="fragment" data-fragment-index="4">通过一点分析，发现阈值接近根号时最优。</span>
                    </p>
                </section>
                <section>
                    <h3>整除分块</h3>
                    <p>观察：$ \left\lfloor \frac{n}{i} \right\rfloor $ 是一个单调递减的函数</p>
                    <p>对于不同的值 $v$，能快速找到所有 $i$ 满足 $ \lfloor \frac{n}{i} \rfloor = v $</p>
                    <p>区间 $[l, r]$ 使得 $\lfloor \frac{n}{i} \rfloor$ 值相同，批量处理</p>
                </section>
                <section>
                    <p>初始化： $ i = 1 $</p>
                    <p>计算当前值： $ v = \left\lfloor \frac{n}{i} \right\rfloor $</p>
                    <p>确定区间右端点： $ r = \left\lfloor \frac{n}{v} \right\rfloor $</p>
                    <p>累计贡献： $ v \times (r - i + 1) $</p>
                    <p>更新 $ i = r + 1 $，重复直到 $ i > n $</p>
                </section>
                <section>
                    <h3>端点结论</h3>
                    <p>考虑函数
                        $$
                        f(i) = \left\lfloor \frac{n}{i} \right\rfloor
                        $$
                    </p>
                    <p>对于固定商值 $v$，满足：</p>
                    <p>
                        $$ \left\lfloor \frac{n}{i} \right\rfloor = v \iff v \le \frac{n}{i} < v+1 $$ </p>
                </section>
                <section>

                    <p>对 $i$ 解不等式：</p>
                    <p>
                        $$
                        \frac{n}{v+1} < i \le \frac{n}{v} $$ </p>
                            <p>区间内的所有 $i$ 具有相同的函数值 $v$，可批量处理</p>
                </section>

                <section>
                    <h3>时间复杂度分析？</h3>
                    <p>使用 根号分治 分析复杂度。</p>
                    <p>提示：我们只需要考虑区间的数量。区间可以根据右端点的特征，分为两类。一类 $\le \sqrt{n}$，另一类 $> \sqrt{n}$。</p>
                </section>
            </section>

            <section>
                <section>
                    <h2>换序技巧</h2>
                </section>
                <section>
                    <p>对于二重求和</p>
                    $$
                    \sum_{i=1}^n \sum_{j=1}^m a_{i,j}
                    $$
                    <p>交换求和顺序</p>
                    $$
                    \sum_{i=1}^n \sum_{j=1}^m a_{i,j} = \sum_{j=1}^m \sum_{i=1}^n a_{i,j}
                    $$
                </section>
                <section>
                    <p>计算
                        $$
                        S = \sum_{i=1}^n \sum_{j=1}^{i} f(i,j)
                        $$
                    </p>
                    <p class="fragment">交换求和顺序，改写为
                        $$
                        S = \sum_{j=1}^n \sum_{i=j}^{n} f(i,j)
                        $$
                    </p>
                </section>

                <section>
                    <p>换序其实是改变对同一集合 $R$ 的遍历顺序，求和结果不变。</p>
                    <p>比如：</p>
                    $$
                    \sum_{i=1}^n \sum_{j=1}^i a_{i,j} = \sum_{j=1}^n \sum_{i=j}^n a_{i,j}
                    $$
                    <p>两边都是对同一区域</p>
                    $$
                    R = \{(i,j) \mid 1 \leq j \leq i \leq n \}
                    $$
                </section>

                <section>
                    <h3>几何直观</h3>
                    <p>把 $(i,j)$ 看成二维平面上的点</p>
                    <p>求和区域 $R$ 是二维点集，比如一个“下三角形”</p>
                    <p>换序就是改变遍历顺序：</p>
                    <ul>
                        <li>可以按列扫描</li>
                        <li>也可以按行扫描</li>
                    </ul>
                </section>

                <section>
                    <p>多重求和不限于二维，三维、四维都可以类似用区域描述：</p>
                    $$
                    \sum_{(i,j,k) \in R} a_{i,j,k}
                    $$
                    <p>换序即调整变量遍历顺序，但区域不变。</p>
                </section>

            </section>

            <section>
                <section>
                    <h2>反演技巧</h2>

                </section>

                <section>
                    <p>很多地方把莫比乌斯反演定义成：</p>
                    <p>设两个函数 $f(n), g(n)$ 满足</p>
                    <p>$$
                        f(n) = \sum_{d \mid n} g(d)
                        $$</p>
                    <p>则可以得到</p>
                    <p>$$
                        g(n) = \sum_{d \mid n} \mu\left(\frac{n}{d}\right) f(d)
                        $$</p>
                </section>

                <section>
                    <p>这个语境下，反演可以解释成：</p>
                    <p>正向地，可以通过 $g$ 的（整除）前缀和表示出 $f$；</p>
                    <p>反向地，如何用 $f$ 的（整除）前缀和表示出 $g$。</p>
                    <p>莫比乌斯反演公式只是反演公式的一角。除了莫比乌斯反演，其实还有二项式反演，最值反演，等。</p>
                    <p>可以说它们都是容斥原理。通过一组容斥系数，使得最后只有我们想要的东西产生非零的贡献。</p>
                </section>

                <section>
                    <h3>Iverson 括号</h3>
                    <p>对任意逻辑命题 \(P\)，定义 Iverson 括号：</p>
                    $$
                    [P] = \begin{cases}
                    1, & \text{如果 } P \text{ 为真} \\
                    0, & \text{如果 } P \text{ 为假}
                    \end{cases}
                    $$
                    <p>也称作指示函数（indicator function）。</p>
                </section>

                <section>
                    <h3>示例</h3>
                    <p>判断 \(x\) 是否为偶数：</p>
                    $$
                    [x \equiv 0 \pmod 2] = \begin{cases}
                    1, & \text{若 } x \text{ 是偶数} \\
                    0, & \text{否则}
                    \end{cases}
                    $$
                </section>

                <section>
                    <h3>结合求和表达</h3>
                    <p>利用 Iverson 括号简化求和条件：</p>
                    $$
                    \sum_{k} [k \text{ 满足某条件}] \cdot f(k)
                    $$
                    <p>跳过不满足条件的项。</p>
                </section>

                <section>

                    <h3>莫比乌斯反演公式</h3>

                    $$
                    f(n) = \sum_{d \mid n} g(d) \Leftrightarrow g(n) = \sum_{d \mid n} \mu\left(\frac{n}{d}\right) f(d)
                    $$

                    <h3>容斥系数</h3>
                    $$
                    \sum_{d \mid n} \mu(d) = [n = 1]
                    $$
                </section>

                <section>
                    <h3>二项式反演公式</h3>
                    <div style="font-size: 80%">
                        $$
                        g(n) = \sum_{k=0}^n \binom{n}{k} f(k)
                        \Leftrightarrow
                        f(n) = \sum_{k=0}^n (-1)^{n-k} \binom{n}{k} g(k)
                        $$
                    </div>
                    <h3>容斥系数</h3>
                    $$
                    \sum_{k=0}^{n}\binom{n}{k}\binom{k}{i} (-1)^{n-k} = [n = i]
                    $$
                </section>

                <section>
                    <h3>和式反演的另一重意味</h3>
                    <p>一般我们希望简化求和，把一个求和表示成一个简单函数。</p>
                    <p>一种迂回的战术：一个简单函数拆成求和，然后作和式变换，重新变回一个更好计算的简单形式。</p>
                </section>
                <section>

                    <p>在纯粹的数论和式变换题，我们经常会直接使用对应的容斥系数公式，来拆开一个简单函数。</p>
                    <p>而在一些综合题里面，我们更倾向于去发现，是不是有两类 dp 数组符合（数论）前缀和的关系。</p>
                    <p>反演公式使得我们只需要找出一个方向的表示，就可以知道另一个方向😋。</p>
                </section>

                <section>
                    <h3>“欧拉反演”</h3>
                    这个恒等式，虽然通常没有上面那样的两种形式。
                    但因为它符合，将一个简单函数拆成求和，然后作和式变换的手法，因此在竞赛圈内得名。
                    $$
                    \sum_{d \mid n} \varphi(d) = n
                    $$
                </section>

                <section>
                    <h3>*关于二项式反演</h3>
                    <div style="font-size: 80%;">
                        <p>
                            如果把二项式系数拆开，二项式反演即
                            $$
                            \frac{f_n}{n!} = \sum_k \left(\frac{g_k}{k!}\right) \cdot \left(\frac{1}{(n-k)!}\right)
                            $$
                            右边其实是多项式卷积的形式。从序列的角度
                            $$
                            \left\{\frac{f_n}{n!}\right\} = \left\{\frac{g_n}{n!}\right\} * \left\{\frac{1}{n!}\right\}
                            $$
                        </p>
                    </div>
                </section>
                <section>
                    <div style="font-size: 80%;">
                        <p>
                            把上面三个序列分别放进形式幂级数 $F(x),G(x),H(x)$。
                        </p>
                        <p>
                            实际上 $H(x)$ 就是经典的 $e^x$。于是
                            $$
                            F(x) = G(x) \times e^{x} \Leftrightarrow G(x) = F(x) \times e^{-x}
                            $$
                            可以验证 $e^{-x}$ 对应的序列，正是 $\left\{\frac{(-1)^n}{n!}\right\}$。
                        </p>
                        <p>
                            除了理论层面给出另一种理解，算法层面，也允许我们使用 FFT 将 $g_i,i=0,1,\cdots,n$ 的信息，
                            用 $O(n\log n)$ 的时间转换成 $f_{i},i=0,1,\cdots,n$ 的信息。反之亦然。
                        </p>
                    </div>
                </section>

            </section>


        </div>
    </div>
    <!-- 用户文件截止 -->









    <!-- 主库 -->
    <script src="dist/reveal.js"></script>

    <!-- 插件 -->
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/search/search.js"></script>
    <!-- <script src="plugin/fullscreen/fullscreen.js"></script> -->
    <!-- <script src="plugin/menu/menu.js"></script> -->
    <script src="plugin/math/math.js"></script>
    <!-- <script src="plugin/autoanimate/autoanimate.js"></script> -->

    <script src="plugin/reveald3.js"></script>

    <!-- 初始化 -->
    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: true,
            controls: true,
            progress: true,
            center: true,
            plugins: [
                RevealMarkdown,
                RevealHighlight,
                RevealNotes,
                RevealZoom,
                RevealSearch,
                // RevealFullscreen,
                // RevealMenu,
                RevealMath,
                // RevealAutoAnimate
                Reveald3,
            ]
        });
    </script>
</body>

</html>