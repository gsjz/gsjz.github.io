<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>AC 自动机演示（分步构造 Fail 指针 + 分步匹配）</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; }
    #status { margin-top: 10px; font-size: 14px; color: #333; }
    svg { border: 1px solid #ccc; margin-top: 10px; }
    .node circle { fill: #fff; stroke: #333; stroke-width: 2px; }
    .node.active circle { fill: orange; }
    .link { fill: none; stroke: #999; stroke-width: 1.5px; }
    .fail { fill: none; stroke-dasharray: 4; }
    .label { font-size: 12px; pointer-events: none; }
    input, button { margin: 5px; padding: 5px; font-size: 16px; }
  </style>
</head>
<body>
  <h2>AC 自动机模拟器</h2>
  <div>
    模式串（逗号分隔）: <input id="patterns" value="he,she,his,her" oninput="patternsChanged()">
    <br>
    文本串：<input id="text" value="ushers" oninput="resetMatch()">
    <br>
    <button onclick="buildAutomaton()">构建自动机</button>
    <button onclick="nextStep()"><span id="btn-label">下一步（构造 Fail）</span></button>
  </div>
  <svg id="viz" width="960" height="500"></svg>
  <div id="status">状态：等待构建自动机</div>

  <script>
    const svg = d3.select("#viz");
    const width = +svg.attr("width");
    let trie, nodeId;
    let nodes = [], links = [], fails = [];
    let phase = 'idle', failSteps = [], failStepIndex = 0, matchStepIndex = 0, currentNode;
    const color = d3.scaleOrdinal(d3.schemeCategory10);

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
    }

    function reset() {
      nodeId = 1;
      trie = { id: 0, children: {}, fail: null, output: [] };
      nodes = []; links = []; fails = [];
      phase = 'idle';
      failSteps = []; failStepIndex = 0;
      matchStepIndex = 0; currentNode = null;
      d3.select('#btn-label').text('下一步（构造 Fail）');
      svg.selectAll('*').remove();
      updateStatus('状态：自动机已重置');
    }

    function patternsChanged() {
      reset();
      updateStatus('状态：模式串已修改，请重新构建自动机');
    }

    function insert(word) {
      let node = trie;
      for (const ch of word) {
        if (!node.children[ch]) {
          node.children[ch] = { id: nodeId++, char: ch, children: {}, fail: null, output: [] };
          links.push({ source: node, target: node.children[ch], label: ch });
        }
        node = node.children[ch];
      }
      node.output.push(word);
    }

    function buildAutomaton() {
      const patterns = document.getElementById('patterns').value.split(',').map(s => s.trim()).filter(s => s);
      if (!patterns.length) { alert('请提供至少一个有效的模式串'); return; }
      reset(); phase = 'fail';
      patterns.forEach(p => insert(p));

      // 构造 Fail 步骤
      const queue = [];
      Object.values(trie.children).forEach(child => {
        child.fail = trie;
        failSteps.push({ source: child, target: trie, mergeOutput: () => { child.output = child.output.concat(trie.output); } });
        queue.push(child);
      });
      for (let i = 0; i < queue.length; i++) {
        const node = queue[i];
        Object.entries(node.children).forEach(([ch, child]) => {
          queue.push(child);
          failSteps.push({
            source: child,
            computeTarget: () => {
              let f = node.fail;
              while (f && !f.children[ch]) f = f.fail;
              return f ? f.children[ch] : trie;
            },
            mergeOutput() {
              const tgt = this.computeTarget();
              child.output = child.output.concat(tgt.output);
            }
          });
        });
      }
      layout(); draw();
      updateStatus('状态：自动机构建完成，准备开始构造 Fail 指针');
    }

    function nextStep() {
      if (phase === 'fail') nextFailStep();
      else if (phase === 'match') nextMatchStep();
      else alert('请先构建自动机');
    }

    function nextFailStep() {
      if (failStepIndex >= failSteps.length) {
        phase = 'match'; currentNode = trie;
        d3.select('#btn-label').text('下一步（文本匹配）');
        updateStatus('状态：Fail 指针构造完毕，准备开始匹配文本');
        return;
      }
      const step = failSteps[failStepIndex++];
      const tgt = step.computeTarget ? step.computeTarget() : step.target;
      // 更新节点 fail 指针
      step.source.fail = tgt;
      fails.push({ source: step.source, target: tgt });
      step.mergeOutput(); draw();
      updateStatus(`状态：构造 Fail (${failStepIndex}/${failSteps.length})，源节点 ID=${step.source.id}`);
    }

    function resetMatch() {
      if (phase !== 'match') return;
      matchStepIndex = 0; currentNode = null;
      draw(); updateStatus('状态：文本已修改，匹配重置');
    }

    function nextMatchStep() {
      const text = document.getElementById('text').value;
      if (!text) { alert('请输入待匹配的文本串'); return; }
      if (matchStepIndex === 0) currentNode = trie;
      if (matchStepIndex >= text.length) { alert('匹配结束'); updateStatus('状态：匹配结束'); return; }
      const ch = text[matchStepIndex];
      // 转移
      while (currentNode && !currentNode.children[ch]) currentNode = currentNode.fail;
      currentNode = currentNode ? currentNode.children[ch] : trie;
      matchStepIndex++;
      draw();
      const out = currentNode.output.length ? ` 匹配到: [${currentNode.output.join(',')}]` : '';
      updateStatus(`状态：匹配第 ${matchStepIndex} 个字符 '${ch}'${out}`);
    }

    function layout() {
      nodes = []; const levels = [];
      (function dfs(n,d){ n.depth=d; (levels[d]=levels[d]||[]).push(n); Object.values(n.children).forEach(c=>dfs(c,d+1)); })(trie,0);
      levels.forEach((lvl,d)=>{ const span=(lvl.length-1)*100; lvl.forEach((n,i)=>{ n.x=width/2+i*100-span/2; n.y=50+d*100; nodes.push(n); }); });
      color.domain(nodes.map(n=>n.id));
    }

    function draw() {
      svg.selectAll('*').remove(); const g=svg.append('g');
      g.selectAll('.link').data(links).join('line')
        .attr('class','link').attr('x1',d=>d.source.x).attr('y1',d=>d.source.y)
        .attr('x2',d=>d.target.x).attr('y2',d=>d.target.y);
      g.selectAll('.link-label').data(links).join('text')
        .attr('class','label').attr('x',d=>(d.source.x+d.target.x)/2)
        .attr('y',d=>(d.source.y+d.target.y)/2-5).text(d=>d.label);
      g.selectAll('.fail').data(fails).join('path')
        .attr('class','fail').attr('d',d=>{const {x:x1,y:y1}=d.source; const {x:x2,y:y2}=d.target; const mx=(x1+x2)/2; return `M${x1},${y1} C${mx},${y1-50} ${mx},${y2+50} ${x2},${y2}`;})
        .attr('stroke',d=>color(d.source.id));
      const sel=g.selectAll('.node').data(nodes).join('g')
        .attr('class',d=>'node'+(d===currentNode?' active':'')).attr('transform',d=>`translate(${d.x},${d.y})`);
      sel.append('circle').attr('r',20);
      sel.append('text').attr('class','label').attr('text-anchor','middle').attr('dy',-5).text(d=>d.id);
      sel.append('text').attr('class','label').attr('text-anchor','middle').attr('dy',15).text(d=>d.output.join(','));
    }
  </script>
</body>
</html>
